#----------------------------------------------------------------------
# Web interface for managing control tables for valid values.
# OCECDR-4193
#----------------------------------------------------------------------
import urllib.parse
import cdr
import cdrcgi
from cdrapi import db

class Control(cdrcgi.Control):
    """
    Manages three separate form pages:
     1. form for selecting a table
     2. form for selecting a value
     3. form for adding/editing a value

    This class/script can be used to support any table of valid values
    comprised as having exactly these columns:
        value_id - primary key (integer) automatically generated by the DBMS
        value_name - required display name for the value (VARCHAR(128)
        value_pos - required unique integer controlling position of value
                    on pick lists

    To add support for such a table, all that is needed is to add the
    name of the table to the Control.TABLES tuple immediately below.
    """

    TABLES = ("summary_translation_state", "summary_change_type")
    FIELDS = ("value_id", "value_name", "value_pos")
    ADD = "Add"
    DROP = "Drop"
    SAVE = "Save"
    CANCEL = "Cancel"
    MAX_VALUE_LEN = 128

    def __init__(self):
        """
        Collect and validate request parameters. Create our own database
        connection and cursor, capable of writing to the database.
        """

        cdrcgi.Control.__init__(self, "Edit Value Tables")
        if not self.session:
            cdrcgi.bail("not authorized")
        if not cdr.canDo(self.session, "MANAGE DB TABLES"):
            cdrcgi.bail("not authorized")
        self.table = self.get_table()
        self.value_id = self.get_value_id()
        self.warning = self.message = None
        self.conn = db.connect()
        self.cursor = self.conn.cursor()

    def run(self):
        """
        Override base class method because we have multiple forms.
        """

        if self.request == self.ADD:
            self.show_form()
        elif self.request == self.DROP:
            self.drop()
        elif self.request == self.SAVE:
            self.save()
        elif self.request == self.SUBMIT:
            self.show_form()
        elif self.request == self.CANCEL:
            cdrcgi.navigateTo(self.script, self.session, table=self.table)
        else:
            cdrcgi.Control.run(self)

    def set_form_options(self, opts):
        """
        Add buttons for extra forms/actions.
        """

        if self.table:
            if self.value_id or self.request == self.ADD:
                opts["buttons"][0] = self.SAVE
                opts["buttons"].insert(1, self.CANCEL)
                if self.value_id:
                    opts["buttons"].insert(2, self.DROP)
            else:
                opts["buttons"][0] = self.ADD
        return opts

    def save(self):
        """
        Save a new or modified row in the selected valid values table.
        """

        value = self.fields.getvalue("value", "").strip()
        position = self.fields.getvalue("position")
        record = self.Value(self.value_id, value, position)
        error = record.validate(self)
        if error:
            self.warning = error
            self.show_form()
        if not record.key:
            cols = ", ".join(self.FIELDS[1:])
            query = "INSERT INTO %s (%s) VALUES (?,?)" % (self.table, cols)
            self.cursor.execute(query, (record.value, record.position))
        else:
            sets = ", ".join([("%s = ?" % col) for col in self.FIELDS[1:]])
            query = "UPDATE %s SET %s WHERE value_id = ?" % (self.table, sets)
            parms = (record.value, record.position, record.key)
            self.cursor.execute(query, parms)
        self.conn.commit()
        cdrcgi.navigateTo(self.script, self.session, table=self.table)

    def drop(self):
        """
        Remove a from the table.

        Confirmation has already been provided via Javascript.
        Will fail with an error message displayed if the value
        is still in use.
        """

        table, id = self.table, self.value_id
        try:
            query = "DELETE FROM %s WHERE value_id = %d" % (table, id)
            self.cursor.execute(query)
            self.conn.commit()
            cdrcgi.navigateTo(self.script, self.session, table=table)
        except Exception:
            args = id, table
            self.logger.exception("failure dropping row %s from %s", *args)
            self.warning = "Value '%s' is in use" % self.map[id].value
            self.show_form()

    def get_table(self):
        """
        Get and validate the 'table' parameter if present (and load its rows).
        """

        table = self.fields.getvalue("table")
        if table:
            if table not in self.TABLES:
                cdrcgi.bail()
            query = db.Query(table, *self.FIELDS)
            self.rows = query.order("value_pos").execute(self.cursor).fetchall()
            self.map = {}
            for row in self.rows:
                self.map[row[0]] = self.Value(*row)
        return table

    def get_value_id(self):
        """
        Get and validate the value's primary key if present.
        """

        value_id = self.fields.getvalue("value_id")
        if not value_id:
            return None
        try:
            value_id = int(value_id)
        except:
            cdrcgi.bail()
        if value_id not in [row[0] for row in self.rows]:
            cdrcgi.bail
        return value_id

    def populate_table_selection_form(self, form):
        """
        Show the form for selecting a database table.
        """

        form.add("<fieldset>")
        form.add(form.B.LEGEND("Select Table"))
        for table in self.TABLES:
            form.add_radio("table", table, table)
        form.add("</fieldset>")

    def populate_value_editing_form(self, form):
        """
        Show the form for editing/adding a value record.
        """

        if self.value_id:
            form.add_script("""\
jQuery("input[value='%s']").click(function(e) {
    if (confirm("Are you sure?"))
        return true;
    e.preventDefault();
});""" % self.DROP)
        form.add_script("""\
jQuery("input[name='value']").attr("maxlength", %d);""" % self.MAX_VALUE_LEN)
        row = self.map.get(self.value_id)
        action = row and "Edit" or "Add"
        value = row and row.value or ""
        position = row and row.position or ""
        value_id = row and str(row.key) or ""
        form.add("<fieldset>")
        form.add_hidden_field("value_id", value_id)
        form.add(form.B.LEGEND("%s Value" % action))
        form.add_text_field("value", "Value", value=value)
        form.add_text_field("position", "Position", value=position)
        form.add("</fieldset>")


    def populate_value_selection_form(self, form):
        """
        Let the user select a table row to edit.
        """

        form.add("<fieldset>")
        form.add(form.B.LEGEND("Values (click link to edit)"))
        form.add("<ul>")
        parms = { "Session": self.session, "table": self.table }
        for key, value, position in self.rows:
            parms["value_id"] = str(key)
            url = "%s?%s" % (self.script, urllib.parse.urlencode(parms))
            display = "%s (position %d)" % (value, position)
            form.add(form.B.LI(form.B.A(display, href=url)))
        form.add("</ul>")
        form.add("</fieldset>")
        return
        style = "table, tr, td, th { background-color: transparent; }"
        form.add_css(style)
        thead = form.B.THEAD(form.B.TH("Value"), form.B.TH("Position"))
        tbody = form.B.TBODY()
        parms = { "Session": self.session, "table": self.table }
        for key, value, position in self.rows:
            parms["value_id"] = str(key)
            url = "%s?%s" % (self.script, urllib.parse.urlencode(parms))
            col1 = form.B.TD(form.B.A(value, href=url))
            col2 = form.B.TD(str(position))
            tbody.append(form.B.TR(col1, col2))
        form.add("<fieldset>")
        form.add(form.B.LEGEND("Values (click link to edit)"))
        form.add(form.B.TABLE(thead, tbody))
        form.add("</fieldset>")

    def populate_form(self, form):
        """
        Puts up one of the three forms identified in the class comment.
        """

        if self.warning:
            form.add(form.B.P(self.warning, form.B.CLASS("error center")))
        if not self.table:
            self.populate_table_selection_form(form)
        else:
            form.add_hidden_field("table", self.table)
            if self.value_id or self.request == self.ADD:
                self.populate_value_editing_form(form)
            else:
                self.populate_value_selection_form(form)
    class Value:
        """
        Column values for a database table row.

        Attributes:
            key - primary key for the row in the table (None if new record)
            value - display string for the record
            position - controls order of values on forms
        """

        def __init__(self, key, value, position):
            """
            Collect the column values for the record.
            """

            self.key = key
            self.value = value
            self.position = position

        def validate(self, control):
            """
            Verify that the record is suitable for saving.

            Return:
                error string on failure
                otherwise None
            """

            if not self.value:
                return "value is required"
            elif not self.position:
                return "position is required"
            try:
                self.position = int(self.position)
            except:
                return "position must be a unique integer value"
            if len(self.value) > control.MAX_VALUE_LEN:
                return "maximum value length is %d" % control.MAX_VALUE_LEN
            lower = self.value.strip()
            for k, v, p in control.rows:
                if k != self.key:
                    if lower == v.lower():
                        return "value name must be unique"
                    elif p == self.position:
                        return "position must be unique"
            return None

if __name__ == "__main__":
    "Let the script be loaded as a module."
    Control().run()
