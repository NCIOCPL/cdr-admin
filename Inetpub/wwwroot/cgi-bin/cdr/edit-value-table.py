#!/usr/bin/env python

"""Manage control tables for valid values.

    Manages three separate form pages:
     1. form for selecting a table
     2. form for selecting a value
     3. form for adding/editing/dropping a value

    This class/script can be used to support any table of valid values
    comprised as having exactly these columns:
        value_id - primary key (integer) automatically generated by the DBMS
        value_name - required display name for the value (VARCHAR(128)
        value_pos - required unique integer controlling position of value
                    on pick lists

    To add support for such a table, all that is needed is to add the
    name of the table to the Control.TABLES tuple immediately below.
"""

from cdrcgi import Controller, navigateTo


class Control(Controller):
    """Access to the database and form-building tools."""

    SUBTITLE = "Edit Value Tables"
    SUBTITLE = "EditValueTables"
    TABLES = (
        "glossary_translation_state",
        "media_translation_state",
        "summary_translation_state",
        "summary_change_type"
    )
    FIELDS = "value_id", "value_name", "value_pos"
    ADD = "Add"
    DROP = "Drop"
    SAVE = "Save"
    CANCEL = "Cancel"
    MAX_VALUE_LEN = 128

    def run(self):
        """Override base class method because we have multiple forms."""

        if not self.session.can_do("MANAGE DB TABLES"):
            self.bail("not authorized")
        if self.request in (self.ADD, self.SUBMIT):
            self.show_form()
        elif self.request == self.DROP:
            self.drop()
        elif self.request == self.SAVE:
            self.save()
        elif self.request == self.CANCEL:
            navigateTo(self.script, self.session.name, table=self.table)
        else:
            Controller.run(self)

    def populate_form(self, page):
        """If we need more information, ask for it.

        Pass:
            page - HTMLPage object on which we draw the form fields
        """

        if not self.table:
            fieldset = page.fieldset("Select Table")
            for table in self.TABLES:
                opts = dict(value=table, label=table)
                fieldset.append(page.radio_button("table", **opts))
        elif self.id or self.request == self.ADD:
            page.form.append(page.hidden_field("table", self.table))
            page.form.append(page.hidden_field("id", self.id))
            value = position = ""
            if self.id:
                value = self.map[self.id].name
                position = self.map[self.id].position
            fieldset = page.fieldset("Unique Value Name and Position")
            field = page.text_field("value", label="Value Name", value=value)
            field.set("maxlength", str(self.MAX_VALUE_LEN))
            fieldset.append(field)
            opts = dict(value=position)
            fieldset.append(page.text_field("position", **opts))
        else:
            page.form.append(page.hidden_field("table", self.table))
            fieldset = page.fieldset("Values (click link to edit a values)")
            ul = page.B.UL()
            params = dict(table=self.table)
            for value in sorted(self.map.values()):
                display = f"{value.name} (position {value.position:d})"
                params["id"] = str(value.id)
                url = self.make_url(self.script, **params)
                ul.append(page.B.LI(page.B.A(display, href=url)))
            fieldset.append(ul)
        page.form.append(fieldset)

    def save(self):
        """Save a new or modified row in the selected valid values table."""

        if not self.id:
            cols = ", ".join(self.FIELDS[1:])
            args = self.value, self.position
            query = f"INSERT INTO {self.table} ({cols}) VALUES (?,?)"
        else:
            sets = ", ".join([f"{col} = ?" for col in self.FIELDS[1:]])
            args = self.value, self.position, self.id
            query = f"UPDATE {self.table} SET {sets} WHERE value_id = ?"
        self.cursor.execute(query, args)
        self.conn.commit()
        navigateTo(self.script, self.session.name, table=self.table)

    def drop(self):
        """Remove a value from the table.

        Will fail with an error message displayed if the value
        is still in use.
        """

        if not self.id:
            self.bail()
        query = f"DELETE FROM {self.table} WHERE value_id = ?"
        try:
            self.cursor.execute(query, self.id)
            self.conn.commit()
            navigateTo(self.script, self.session, table=self.table)
        except Exception as e:
            args = self.id, self.table
            self.logger.exception("failure dropping row %s from %s", *args)
            self.bail(e)

    @property
    def buttons(self):
        """Customize the button list, depending on what's going on."""

        buttons = [self.DEVMENU, self.ADMINMENU, self.LOG_OUT]
        if self.table:
            if self.id or self.request == self.ADD:
                if self.id:
                    return [self.SAVE, self.CANCEL, self.DROP] + buttons
                return [self.SAVE, self.CANCEL] + buttons
            return [self.ADD] + buttons
        return [self.SUBMIT] + buttons

    @property
    def id(self):
        """Primary key for the current value."""

        if not hasattr(self, "_id"):
            self._id = None
            id = self.fields.getvalue("id", "").strip()
            if id:
                try:
                    self._id = int(id)
                except Exception:
                    self.bail()
            if self._id and self._id not in self.map:
                self.bail()
        return self._id

    @property
    def map(self):
        """Dictionary of `Value` objects, indexed by `value_id`."""

        if not hasattr(self, "_map"):
            self._map = {}
            if self.table:
                query = self.Query(self.table, *self.FIELDS)
                for row in query.execute(self.cursor).fetchall():
                    value = self.Value(row)
                    self._map[value.id] = value
        return self._map

    @property
    def position(self):
        """Indication of where this value should be display in picklists."""

        if not hasattr(self, "_position"):
            self._position = None
            string_value = self.fields.getvalue("position", "").strip()
            if string_value:
                try:
                    self._position = int(string_value)
                except Exception:
                    self.bail("position must be an integer")
            if isinstance(self._position, int):
                for value in self.map.values():
                    if self._position == value.position:
                        if self.id != value.id:
                            self.bail("position must be unique")
            elif self.request == self.SAVE:
                self.bail("Position is required")
        return self._position

    @property
    def table(self):
        """Table selected by the user from the landing page form."""

        if not hasattr(self, "_table"):
            self._table = self.fields.getvalue("table")
            if self._table:
                if self._table not in self.TABLES:
                    self.bail()
        return self._table

    @property
    def value(self):
        """String for the `value_name` column."""

        if not hasattr(self, "_value"):
            self._value = self.fields.getvalue("value", "").strip()
            if self._value:
                name = self._value.lower()
                for value in self.map.values():
                    if name == value.name.lower() and self.id != value.id:
                        self.bail("Value name must be unique")
            elif self.request == self.SAVE:
                self.bail("Value name is required")
        return self._value

    class Value:
        """Column values for a database table row."""

        def __init__(self, row):
            """Save the caller's value.

            Pass:
                row - record from the query's results
            """

            self.__row = row

        def __lt__(self, other):
            """Sort by position, not name."""
            return self.position < other.position

        @property
        def id(self):
            """Primary key for the value."""
            return self.__row.value_id

        @property
        def name(self):
            """String for this valid value's name."""
            return self.__row.value_name

        @property
        def position(self):
            """Integer for where this value should appear in picklists."""
            return self.__row.value_pos


if __name__ == "__main__":
    "Let the script be loaded as a module."
    Control().run()
